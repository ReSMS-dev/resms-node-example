type SendOtpOptions = {
    to: string;
    message: `${string}{CODE}${string}`;
    senderId?: string;
    codeType?: OtpCode;
    codeLength?: number;
    validityMinutes?: number;
};
type SendOtpResponse = {
    data: {
        phoneNumber: string;
        expiresAt: string;
    };
};
declare enum OtpCode {
    NUMERIC = 0,
    ALPHA = 1
}

type VerifyOtpOptions = {
    to: string;
    code: string;
};
type VerifyOtpResponse = {
    data: {
        otpId: string;
        phoneNumber: string;
        verifiedAt: string;
    };
};

declare class Otp {
    private readonly resms;
    constructor(resms: ReSMS);
    send(sendOtpOptions: SendOtpOptions): Promise<SendOtpResponse>;
    verify(verifyOtpOptions: VerifyOtpOptions): Promise<VerifyOtpResponse>;
}

type SendSmsOptions = {
    to: string;
    message: string;
    senderId: string | undefined;
};
type SendSmsResponse = {
    data: {
        messageId: string;
    };
};

declare class Sms {
    private readonly resms;
    constructor(resms: ReSMS);
    send(sendSmsOptions: SendSmsOptions): Promise<SendSmsResponse>;
}

type ReSMSResponse = SendSmsResponse | SendOtpResponse | VerifyOtpResponse;
type ErrorResponse = {
    status: string;
    error: ErrorContent;
};
type ErrorContent = {
    name: string;
    message: string;
};

declare class ReSMS {
    readonly key: string;
    private readonly headers;
    readonly sms: Sms;
    readonly otp: Otp;
    constructor(key: string);
    fetchRequest(path: string, options?: {}): Promise<ReSMSResponse>;
    private handleResponse;
    get(path: string): Promise<ReSMSResponse>;
    post(path: string, payload?: unknown): Promise<ReSMSResponse>;
}

export { type ErrorContent, type ErrorResponse, OtpCode, ReSMS, type ReSMSResponse, type SendOtpOptions, type SendOtpResponse, type SendSmsOptions, type SendSmsResponse, type VerifyOtpOptions, type VerifyOtpResponse };
